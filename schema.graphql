type AlertEmitterNode implements Node {
	created: AtBy!
	description: String
	lastModified: AtBy!
	name: String!
	sendMessageType: MessageType!
	tenant: Tenant!
}

type ApiUser {
	config: AWSJSON!
	created: AtBy!
	description: String
	lastModified: AtBy!
	role: ApiUserRole!
	tenant: Tenant!
	username: String!

	Delete: Boolean!
	Update(description: String, role: ApiUserRole): ApiUser!
}

type ApiUserResult {
	items: [ApiUser]
	lastEvaluatedKey: AWSJSON
	scannedCount: Int
}

enum ApiUserRole {
	admin
	read_only
	user
}

interface App {
	created: AtBy!
	description: String
	lastModified: AtBy!
	name: String!
	tenant: Tenant!

	Delete(drainEdges: Boolean): Boolean!
}

type AppResult {
	items: [App]
	lastEvaluatedKey: AWSJSON
	scannedCount: Int
}

type AtBy {
	at: AWSDateTime
	by: String
}

type BitmapperFunction implements Function @aws_cognito_user_pool {
	argumentMessageType: MessageType!
	code: String!
	created: AtBy!
	description: String!
	lastModified: AtBy!
	name: String!
	readme: String
	requirements: [String!]
	system: Boolean!
	tenant: Tenant

	Delete: Boolean!
	Update(code: String, description: String, readme: String, requirements: [String!]): BitmapperFunction!
	Validate(message: String!, code: String, loggingLevel: LogLevel): ValidationResult!
}

type BulkDataStorage {
	presignedGet: AWSURL!
	presignedPost: PresignedPost!
}

type Change {
	created: AtBy!
	old: Echo
	new: Echo
}

type ChangeEmitterNode implements Node {
	created: AtBy!
	description: String
	lastModified: AtBy!
	name: String!
	sendMessageType: MessageType!
	tenant: Tenant!
}

type ChangeNotification {
	app: String
	change: Change!
	tenant: String!
}

type ChangeResult {
	items: [Change]!
	lastEvaluatedKey: AWSJSON
	scannedCount: Int
}

enum ContentEncoding {
	gzip
	deflate
}

type CrossAccountApp implements App {
	account: String!
	config: AWSJSON
	created: AtBy!
	description: String
	iamPolicy: AWSJSON!
	lastModified: AtBy!
	name: String!
	nodes: [ExternalNode]
	tenant: Tenant!

	Delete(drainEdges: Boolean): Boolean!
	ResetPassword: CrossAccountApp!
	Update(description: String): CrossAccountApp!
}

type CrossTenantReceivingApp implements App {
	created: AtBy!
	description: String
	lastModified: AtBy!
	name: String!
	nodes: [CrossTenantReceivingNode]
	sendingApp: String
	sendingTenant: String!
	tenant: Tenant!

	Delete(drainEdges: Boolean): Boolean!
	Update(description: String): CrossTenantReceivingApp!
}

type CrossTenantReceivingNode implements Node {
	app: CrossTenantReceivingApp!
	created: AtBy!
	description: String
	lastModified: AtBy!
	name: String!
	sendEdges: [Edge]
	sendMessageType: MessageType
	tenant: Tenant!

	Delete(drainEdges: Boolean): Boolean!
	Update(description: String): CrossTenantReceivingNode!
}

type CrossTenantSendingApp implements App {
	created: AtBy!
	description: String
	lastModified: AtBy!
	name: String!
	nodes: [CrossTenantSendingNode]
	receivingApp: String!
	receivingTenant: String!
	tenant: Tenant!
	
	Delete(drainEdges: Boolean): Boolean!
	Update(description: String): CrossTenantSendingApp!
}

type CrossTenantSendingNode implements Node {
	app: CrossTenantSendingApp!
	config: AWSJSON
	created: AtBy!
	description: String
	inlineTransformer: String
	lastModified: AtBy!
	managedTransformer: TransformerFunction
	name: String!
	receiveEdges: [Edge]
	receiveMessageType: MessageType
	requirements: [String!]
	sequentialProcessing: Boolean
	tenant: Tenant!

	Delete(drainEdges: Boolean): Boolean!
	ListLogEvents(endDateTime: AWSDateTime, filterPattern: String, limit: Int, nextToken: String, startDateTime: AWSDateTime): LogEventResults!
	Update(config: AWSJSON, description: String, inlineTransformer: String, managedTransformer: String, requirements: [String!], sequentialProcessing: Boolean): CrossTenantSendingNode!
	Validate(message: String!, code: String, loggingLevel: LogLevel): ValidationResult!
}

type DockerConfig {
	imageUrl: String!
	password: String
	username: String
}

input DockerConfigInput {
	imageUrl: String!
	password: String
	username: String
}

union Echo = AlertEmitterNode | BitmapperFunction | ChangeEmitterNode | CrossAccountApp | CrossTenantReceivingApp | CrossTenantReceivingNode | CrossTenantSendingApp | CrossTenantSendingNode | Edge |  ExternalApp | ExternalNode | KmsKey | LogEmitterNode | ManagedApp | ManagedNode | ManagedNodeType | MessageType | RouterNode | Tenant | TransformerFunction | TransformerNode

type Edge {
	created: AtBy!
	description: String
	kmsKey: KmsKey!
	lastModified: AtBy!
	messageCounts: MessageCounts!
	messageType: MessageType!
	queue: AWSURL!
	source: Node!
	target: Node!
	tenant: Tenant!

	Delete(drain: Boolean): Boolean!
	Move(source: String!, target: String): Edge!
	Purge: Boolean!
	Update(description: String): Edge!
}

type EdgeResult {
	items: [Edge]
	lastEvaluatedKey: AWSJSON
	scannedCount: Int
}

type ExternalApp implements App {
	created: AtBy!
	config: AWSJSON
	description: String
	lastModified: AtBy!
	name: String!
	nodes: [ExternalNode]
	tenant: Tenant!

	Delete(drainEdges: Boolean): Boolean!
	ResetPassword: ExternalApp!
	Update(description: String): ExternalApp!
}

type ExternalNode implements Node {
	app: ExternalApp!
	config: AWSJSON
	created: AtBy!
	description: String
	lastModified: AtBy!
	name: String!
	receiveEdges: [Edge]
	receiveMessageType: MessageType
	sendEdges: [Edge]
	sendMessageType: MessageType
	tenant: Tenant!

	Delete(drainEdges: Boolean): Boolean!
	Update(config: AWSJSON, description: String): ExternalNode!
}

interface Function {
	argumentMessageType: MessageType!
	code: String!
	created: AtBy!
	description: String!
	name: String!
	lastModified: AtBy!
	readme: String
	requirements: [String!]
	system: Boolean!
	tenant: Tenant

	Delete: Boolean!
	Validate(message: String!, code: String, loggingLevel: LogLevel): ValidationResult!
}

type FunctionResult {
	items: [Function]
	lastEvaluatedKey: AWSJSON
	scannedCount: Int
}

type Healthcheck {
	interval: String!
	retries: Int!
	startPeriod: String!
	test: String!
	timeout: String!
}

input HealthcheckInput {
	interval: String!
	retries: Int!
	startPeriod: String!
	test: String!
	timeout: String!
}

type HostMount {
	containerPath: String!
	description: String!
	hostPath: String!
}

input HostMountInput {
	containerPath: String!
	description: String
	hostPath: String!
}

type HostMountRequirement {
	containerPath: String!
	description: String!
}

input HostMountRequirementInput {
	containerPath: String!
	description: String!
}

type LogEmitterNode implements Node {
	created: AtBy!
	description: String
	lastModified: AtBy!
	name: String!
	sendMessageType: MessageType!
	tenant: Tenant!
}

type LoginUser {
	activeDate: String
	created: AtBy!
	email: AWSEmail!
	firstName: String!
	lastModified: AtBy!
	lastName: String!
	tenantUsers: [TenantUser!]
}

type KmsKey {
	arn: String!
	created: AtBy!
	description: String
	lastModified: AtBy!
	name: String!
	tenant: Tenant!

	Delete: Boolean!
	Update(description: String): KmsKey!
}

type KmsKeyResult {
	items: [KmsKey]
	lastEvaluatedKey: AWSJSON
	scannedCount: Int
}

type LogEvent {
	timestamp: AWSDateTime!
	message: String!
	ingestionTime: AWSDateTime!
}

type LogEventResults {
	items: [LogEvent]!
	nextToken: String
}

enum LogLevel {
	DEBUG
	ERROR
	INFO
	WARNING
}

type ManagedApp implements App {
	config: AWSJSON
	created: AtBy!
	description: String
	managedInstances: [ManagedInstance]
	iso: String!
	lastModified: AtBy!
	name: String!
	nodes: [ManagedNode]
	tenant: Tenant!

	Delete(drainEdges: Boolean): Boolean!
	DeregisterManagedInstance(instanceId: String!): Boolean!
	ResetPassword: ManagedApp!
	Update(description: String): ManagedApp!
}

type ManagedInstance {
	activationId: String!
	hostname: String!
	instanceId: String!
	ipAddress: AWSIPAddress!
	lastPingDateTime: AWSDateTime!
	pingStatus: PingStatus!
	registrationDate: AWSDateTime!
}

type ManagedNode implements Node {
	app: ManagedApp!
	config: AWSJSON
	created: AtBy!
	description: String
	hostMounts: [HostMount!]
	lastModified: AtBy!
	managedNodeType: ManagedNodeType!
	name: String!
	portMappings: [PortMapping!]
	receiveEdges: [Edge]
	receiveMessageType: MessageType
	sendEdges: [Edge]
	sendMessageType: MessageType
	tenant: Tenant!

	Delete(drainEdges: Boolean): Boolean!
	ListLogEvents(endDateTime: AWSDateTime, filterPattern: String, limit: Int, nextToken: String, startDateTime: AWSDateTime): LogEventResults!
	Update(config: AWSJSON, description: String, hostMounts: [HostMountInput!], portMappings: [PortMappingInput!]): ManagedNode!
}

type ManagedNodeType {
	configTemplate: AWSJSON
	created: AtBy!
	description: String
	dockerConfig: DockerConfig!
	healthcheck: Healthcheck
	hostMountRequirements: [HostMountRequirement!]
	lastModified: AtBy!
	name: String!
	portMappingRequirements: [PortMappingRequirement!]
	readme: String
	receiveMessageType: MessageType
	sendMessageType: MessageType
	system: Boolean!
	tenant: Tenant
	volumes: [String!]

	Delete: Boolean!
	Update(description: String, healthcheck: Healthcheck, readme: String, volumes: [String!]): ManagedNodeType!
}

type ManagedNodeTypeResult {
	items: [ManagedNodeType]
	lastEvaluatedKey: AWSJSON
	scannedCount: Int
}

type MessageCounts {
	approximateNumberOfMessages: Int!
	approximateNumberOfMessagesDelayed: Int!
	approximateNumberOfMessagesNotVisible: Int!
}

type MessageType {
	auditor: String!
	bitmapperTemplate: String!
	created: AtBy!
	description: String
	lastModified: AtBy!
	name: String!
	readme: String
	requirements: [String!]
	system: Boolean!
	tenant: Tenant
	transformerTemplate: String!
	
	Delete: Boolean!
	Update(auditor: String, bitmapperTemplate: String, description: String, readme: String, requirements: [String!], transformerTemplate: String): MessageType!
	Validate(message: String!, code: String, loggingLevel: LogLevel): ValidationResult!
}

type MessageTypeResult {
	items: [MessageType]
	lastEvaluatedKey: AWSJSON
	scannedCount: Int
}

type Mutation {
	CreateApiUser(tenant: String!, role: ApiUserRole!, description: String): ApiUser!
	CreateBitmapperFunction(
		tenant: String!,
		name: String!,
		code: String!,
		description: String!,
		argumentMessageType: String!,
		readme: String,
		requirements: [String!]
	): BitmapperFunction!
	CreateChangeNotification(tenant: String!, app: String, old: AWSJSON, new: AWSJSON): ChangeNotification!
	@aws_iam
	CreateCrossAccountApp(
		tenant: String!,
		name: String!,
		description: String,
		account: String!
	): ExternalApp!
	CreateCrossTenantReceivingApp(
		tenant: String!, 
		name: String!, 
		sendingTenant: String!, 
		description: String
	): CrossTenantReceivingApp!
	CreateCrossTenantSendingApp(
		tenant: String!,
		name: String!,
		description: String,
		receivingTenant: String!,
		receivingApp: String!
	): CrossTenantSendingApp!
	CreateCrossTenantSendingNode(
		tenant: String!,
		app: String!,
		name: String!,
		receiveMessageType: String!,
		description: String,
		config: AWSJSON,
		sendMessageType: String,
		inlineTransformer: String,
		managedTransformer: String,
		sequentialProcessing: Boolean,
		requirements: [String!]
	): CrossTenantSendingNode!
	CreateEdge(
		tenant: String!, 
		source: String!, 
		target: String!, 
		kmsKey: String, 
		description: String
	): Edge!
	CreateExternalApp(
		tenant: String!,
		name: String!,
		description: String,
	): ExternalApp!
	CreateExternalNode(
		tenant: String!,
		app: String!,
		name: String!,
		receiveMessageType: String,
		sendMessageType: String
		description: String,
		config: AWSJSON,
	): ExternalNode!
	CreateKmsKey(tenant: String!, 	name: String!, description: String): KmsKey!
	CreateManagedApp(tenant: String!, name: String!, description: String): ManagedApp!
	CreateManagedNode(
		tenant: String!,
		app: String!,
		name: String!,
		managedNodeType: String!,
		description: String,
		config: AWSJSON,
		portMappings: [PortMappingInput!],
		hostMounts: [HostMountInput!]
	): ManagedNode!
	CreateManagedNodeType(
		tenant: String!, 
		name: String!,
		configTemplate: AWSJSON,
		description: String,
		dockerConfig: DockerConfigInput!,
		healthcheck: HealthcheckInput
		hostMountRequirements: [HostMountRequirementInput!],
		portMappingRequirements: [PortMappingRequirementInput!],
		readme: String,
		receiveMessageType: String,
		sendMessageType: String,
		volumes: [String!],
	): ManagedNodeType!
	CreateMessageType(
		tenant: String!, 
		name: String!,
		auditor: String!,
		transformerTemplate: String!,
		bitmapperTemplate: String!,
		readme: String,
		requirements: [String!]
	): MessageType!
	CreateRouterNode(
		tenant: String!,
		name: String!,
		receiveMessageType: String!,
		inlineBitmapper: String,
		routeTable: AWSJSON!,
		managedBitmapper: String
		description: String,
		config: AWSJSON,
		requirements: [String!]
	): RouterNode!
	CreateTenant(name: String!, region: Region!, config: AWSJSON): Tenant!
	CreateTransformerFunction(
		tenant: String!,
		name: String!,
		code: String!,
		description: String!,
		argumentMessageType: String!,
		readme: String,
		resultMessageType: String!,
		requirements: [String!]
	): TransformerFunction!
	CreateTransformerNode(
		tenant: String!,
		name: String!,
		receiveMessageType: String!,
		description: String,
		config: AWSJSON,
		sendMessageType: String,
		inlineTransformer: String,
		managedTransformer: String,
		sequentialProcessing: Boolean,
		requirements: [String!]
	): TransformerNode!
}

interface Node {
	created: AtBy!
	description: String
	lastModified: AtBy!
	name: String!
	tenant: Tenant!
}

type NodeResult {
	items: [Node]
	lastEvaluatedKey: AWSJSON
	scannedCount: Int
}

enum PingStatus {
	ConnectionLost
	Inactive
	Online
}

type PortMapping {
	containerPort: Int!
	description: String!
	hostPort: Int!
}

input PortMappingInput {
	containerPort: Int!
	hostPort: Int!
}

type PortMappingRequirement {
	containerPort: Int!
	description: String!
}

input PortMappingRequirementInput {
	containerPort: Int!
	description: String!
}

type PresignedPost {
	expiration: AWSTimestamp!
	fields: AWSJSON!
	url: AWSURL!
}

type Query {
	GetApiUser(tenant: String!, username: String!): ApiUser
	GetApp(name: String!, tenant: String!): App
	GetBulkDataStorage(tenant: String!, contentEncoding: ContentEncoding, count: Int): [BulkDataStorage!]!
	GetEdge(source: String!, target: String!, tenant: String!): Edge
	GetFunction(name: String!, tenant: String): Function
	GetKmsKey(name: String!, tenant: String!): KmsKey
	GetManagedNodeType(name: String!, tenant: String): ManagedNodeType
	GetMessageType(name: String!, tenant: String): MessageType
	GetNode(name: String!, tenant: String!): Node
	GetTenant(tenant: String!): Tenant
	GetTenantUser(tenant: String!, email: AWSEmail!): TenantUser
	GetUser: LoginUser

	ListApiUsers(tenant: String!, limit: Int, startKey: AWSJSON): ApiUserResult
	ListApps(tenant: String!, limit: Int, nameContains: String, startKey: AWSJSON): AppResult
	ListFunctions(limit: Int, startKey: AWSJSON, tenant: String): FunctionResult
	ListKeys(tenant: String!, limit: Int, startKey: AWSJSON): KmsKeyResult
	ListNodes(tenant: String!, limit: Int, nameContains: String, startKey: AWSJSON): NodeResult
	ListManagedNodeTypes(limit: Int, startKey: String, tenant: String): ManagedNodeTypeResult
	ListMessageTypes(limit: Int, startKey: String, tenant: String): MessageTypeResult
	ListTenants(limit: Int, startKey: String): TenantResult
	ListTenantUsers(tenant: String!, limit: Int, startKey: AWSJSON): TenantUserResult
}

enum Region {
	af_south_1
	ap_east_1
	ap_northeast_1
	ap_northeast_2
	ap_northeast_3
	ap_south_1
	ap_southeast_1
	ap_southeast_2
	ca_central_1
	eu_central_1
	eu_north_1
	eu_south_1
	eu_west_1
	eu_west_2
	eu_west_3
	me_south_1
	sa_east_1
	us_east_1
	us_east_2
	us_west_1
	us_west_2
	us_gov_east_1
	us_gov_west_1
}

type RouterNode implements Node {
	config: AWSJSON
	created: AtBy!
	description: String
	inlineBitmapper: String
	lastModified: AtBy!
	managedBitmapper: BitmapperFunction
	name: String!
	receiveEdges: [Edge]
	receiveMessageType: MessageType
	requirements: [String!]
	routeTable: AWSJSON!
	sendEdges: [Edge]
	sendMessageType: MessageType
	tenant: Tenant!

	Delete(drainEdges: Boolean): Boolean!
	ListLogEvents(endDateTime: AWSDateTime, filterPattern: String, limit: Int, nextToken: String, startDateTime: AWSDateTime): LogEventResults!
	Update(config: AWSJSON, description: String, inlineBitmapper: String, managedBitmapper: String, requirements: [String!], routeTable: AWSJSON): RouterNode!
	Validate(message: String!, code: String, loggingLevel: LogLevel): ValidationResult!
}

type Subscription {
	onChange(tenant: String!, app: String): ChangeNotification
	@aws_subscribe(mutations: ["CreateChangeNotification"])
}

type Tenant {
	config: AWSJSON
	created: AtBy!
	description: String
	lastModified: AtBy!
	name: String!
	region: String!
	users: [TenantUser!]

	AddUser(email: String!, role: UserRole!): TenantUser!
	Delete: Boolean!
	ListChanges(endDateTime: AWSDateTime, limit: Int, startDateTime: AWSDateTime, startKey: AWSJSON): ChangeResult!
	Update(config: AWSJSON, description: String): Tenant!
}

type TenantResult {
	items: [Tenant]
	lastEvaluatedKey: AWSJSON
	scannedCount: Int
}

type TenantUser {
	activeDate: String
	created: AtBy!
	email: AWSEmail!
	firstName: String
	invitationDate: String
	invitationToken: String
	lastModified: AtBy!
	lastName: String
	role: UserRole!
	status: UserStatus!
	tenant: Tenant!

	Delete: Boolean!
	Update(role: UserRole, status: UserStatus): TenantUser!
}

type TenantUserResult {
	items: [TenantUser]
	lastEvaluatedKey: AWSJSON
	scannedCount: Int
}

type TransformerFunction implements Function @aws_cognito_user_pool {
	argumentMessageType: MessageType!
	code: String!
	created: AtBy!
	description: String!
	lastModified: AtBy!
	name: String!
	readme: String
	requirements: [String!]
	resultMessageType: MessageType!
	system: Boolean!
	tenant: Tenant

	Delete: Boolean!
	Update(code: String, description: String, readme: String, requirements: [String!]): TransformerFunction!
	Validate(message: String!, code: String, loggingLevel: LogLevel): ValidationResult!
}

type TransformerNode implements Node {
	config: AWSJSON
	created: AtBy!
	description: String
	inlineTransformer: String
	lastModified: AtBy!
	managedTransformer: TransformerFunction
	name: String!
	receiveEdges: [Edge]
	receiveMessageType: MessageType
	requirements: [String!]
	sendEdges: [Edge]
	sendMessageType: MessageType
	sequentialProcessing: Boolean
	tenant: Tenant!

	Delete(drainEdges: Boolean): Boolean!
	ListLogEvents(endDateTime: AWSDateTime, filterPattern: String, limit: Int, nextToken: String, startDateTime: AWSDateTime): LogEventResults!
	Update(config: AWSJSON, description: String, inlineTransformer: String, managedTransformer: String, requirements: [String!], sequentialProcessing: Boolean): TransformerNode!
	Validate(message: String!, code: String, loggingLevel: LogLevel): ValidationResult!
}

enum UserRole {
	admin
	owner
	read_only
	user
}

enum UserStatus {
	active
	inactive
	invited
	pending
}

type ValidationResult {
	result: String!
	stdout: String!
}

