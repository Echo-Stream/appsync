type AlertEmitterNode implements Node {
	created: AtBy!
	description: String
	lastModified: AtBy!
	name: String!
	tenant: Tenant!
}

type ApiUser {
	config: AWSJSON!
	created: AtBy!
	description: String
	lastModified: AtBy!
	role: ApiUserRole!
	tenant: Tenant!
	username: String!

	Delete: Boolean!
	Update(description: String, role: ApiUserRole): ApiUser!
}

type ApiUserResult {
	items: [ApiUser]
	lastEvaluatedKey: AWSJSON
	scannedCount: Int
}

enum ApiUserRole {
	admin
	read_only
	user
}

interface App {
	created: AtBy!
	description: String
	lastModified: AtBy!
	name: String!
	tenant: Tenant!

	Delete(drainEdges: Boolean): Boolean!
}

type AppResult {
	items: [App]
	lastEvaluatedKey: AWSJSON
	scannedCount: Int
}

type AtBy {
	at: AWSDateTime
	by: String
}

type BitmapperFunction implements Function @aws_cognito_user_pool {
	argumentMessageType: MessageType!
	code: String!
	created: AtBy!
	description: String!
	lastModified: AtBy!
	name: String!
	requirements: [String!]
	system: Boolean!
	tenant: Tenant

	Delete: Boolean!
	Update(code: String, description: String, requirements: [String!]): BitmapperFunction!
	Validate(message: String!, code: String, loggingLevel: LogLevel): ValidateResult!
}

enum ContentEncoding {
	gzip
	deflate
}

type CrossAccountApp implements App {
	account: String!
	config: AWSJSON
	created: AtBy!
	description: String
	lastModified: AtBy!
	name: String!
	nodes: [ExternalNode]
	tenant: Tenant!

	Delete(drainEdges: Boolean): Boolean!
	ResetPassword: CrossAccountApp!
	Update(description: String): CrossAccountApp!
}

type DockerConfig {
	imageUrl: String!
	password: String
	username: String
}

input DockerConfigInput {
	imageUrl: String!
	password: String
	username: String
}

type Edge {
	created: AtBy!
	description: String
	kmsKey: KmsKey!
	lastModified: AtBy!
	messageType: MessageType!
	queue: AWSURL!
	source: Node!
	target: Node!
	tenant: Tenant!

	Delete(drain: Boolean): Boolean!
	Move(source: String!, target: String): Edge!
	Purge: Boolean!
	Update(description: String): Edge!
}

type EdgeResult {
	items: [Edge]
	lastEvaluatedKey: AWSJSON
	scannedCount: Int
}

type ExternalApp implements App {
	created: AtBy!
	config: AWSJSON
	description: String
	lastModified: AtBy!
	name: String!
	nodes: [ExternalNode]
	tenant: Tenant!

	Delete(drainEdges: Boolean): Boolean!
	ResetPassword: ExternalApp!
	Update(description: String): ExternalApp!
}

type ExternalNode implements Node {
	app: ExternalApp!
	config: AWSJSON
	created: AtBy!
	description: String
	lastModified: AtBy!
	name: String!
	receiveEdges: [Edge]
	receiveMessageType: MessageType
	sendEdges: [Edge]
	sendMessageType: MessageType
	tenant: Tenant!

	Delete(drainEdges: Boolean): Boolean!
	Update(config: AWSJSON, description: String): ExternalNode!
}

interface Function {
	argumentMessageType: MessageType!
	code: String!
	created: AtBy!
	description: String!
	name: String!
	lastModified: AtBy!
	requirements: [String!]
	system: Boolean!
	tenant: Tenant

	Delete: Boolean!
	Validate(message: String!, code: String, loggingLevel: LogLevel): ValidateResult!
}

type FunctionResult {
	items: [Function]
	lastEvaluatedKey: AWSJSON
	scannedCount: Int
}

type Healthcheck {
	interval: String!
	retries: Int!
	startPeriod: String!
	test: String!
	timeout: String!
}

input HealthcheckInput {
	interval: String!
	retries: Int!
	startPeriod: String!
	test: String!
	timeout: String!
}

type HostMount {
	containerPath: String!
	description: String!
	hostPath: String!
}

input HostMountInput {
	containerPath: String!
	description: String
	hostPath: String!
}

type HostMountRequirement {
	containerPath: String!
	description: String!
}

input HostMountRequirementInput {
	containerPath: String!
	description: String!
}

type LoginUser {
	activeDate: String
	created: AtBy!
	email: AWSEmail!
	firstName: String!
	lastModified: AtBy!
	lastName: String!
	tenantUsers: [TenantUser!]
}

type KmsKey {
	arn: String!
	created: AtBy!
	description: String
	lastModified: AtBy!
	name: String!
	tenant: Tenant!

	Delete: Boolean!
	Update(description: String): KmsKey!
}

type KmsKeyResult {
	items: [KmsKey]
	lastEvaluatedKey: AWSJSON
	scannedCount: Int
}

type LargeMessageStorage {
	presignedGet: AWSURL!
	presignedPost: PresignedPost!
}

type LogEvent {
	timestamp: AWSDateTime!
	message: String!
	ingestionTime: AWSDateTime!
}

type LogEventResults {
	items: [LogEvent]!
	nextToken: String
}

enum LogLevel {
	DEBUG
	ERROR
	INFO
	WARNING
}

type ManagedApp implements App {
	config: AWSJSON
	created: AtBy!
	description: String
	managedInstances: [ManagedInstance]
	iso: String!
	lastModified: AtBy!
	name: String!
	nodes: [ManagedNode]
	tenant: Tenant!

	Delete(drainEdges: Boolean): Boolean!
	DeregisterManagedInstance(instanceId: String!): Boolean!
	ResetPassword: ManagedApp!
	Update(description: String): ManagedApp!
}

type ManagedInstance {
	activationId: String!
	hostname: String!
	instanceId: String!
	ipAddress: AWSIPAddress!
	lastPingDateTime: AWSDateTime!
	pingStatus: PingStatus!
	registrationDate: AWSDateTime!
}

type ManagedNode implements Node {
	app: ManagedApp!
	config: AWSJSON
	created: AtBy!
	description: String
	hostMounts: [HostMount!]
	lastModified: AtBy!
	managedNodeType: ManagedNodeType!
	name: String!
	portMappings: [PortMapping!]
	receiveEdges: [Edge]
	receiveMessageType: MessageType
	sendEdges: [Edge]
	sendMessageType: MessageType
	tenant: Tenant!

	Delete(drainEdges: Boolean): Boolean!
	ListLogEvents(endDateTime: AWSDateTime, filterPattern: String, limit: Int, nextToken: String, startDateTime: AWSDateTime): LogEventResults!
	Update(config: AWSJSON, description: String, hostMounts: [HostMount!], portMappings: [PortMapping!]): ManagedNode!
}

type ManagedNodeType {
	configTemplate: AWSJSON
	created: AtBy!
	description: String
	dockerConfig: DockerConfig!
	healthcheck: Healthcheck
	hostMountRequirements: [HostMountRequirement!]
	lastModified: AtBy!
	name: String!
	portMappingRequirements: [PortMappingRequirement!]
	receiveMessageType: MessageType
	sendMessageType: MessageType
	system: Boolean!
	tenant: Tenant
	volumes: [String!]

	Delete: Boolean!
	Update(description: String!): ManagedNodeType!
}

type ManagedNodeTypeResult {
	items: [ManagedNodeType]
	lastEvaluatedKey: AWSJSON
	scannedCount: Int
}

type MessageType {
	auditor: String!
	bitmapperTemplate: String!
	created: AtBy!
	description: String,
	lastModified: AtBy!
	name: String!
	requirements: [String!]
	system: Boolean!
	tenant: Tenant
	transformerTemplate: String!
	
	Delete: Boolean!
	Update(auditor: String, bitmapperTemplate: String, description: String, requirements: [String!], transformerTemplate: String): MessageType!
	Validate(message: String!, code: String, loggingLevel: LogLevel): ValidateResult!
}

type MessageTypeResult {
	items: [MessageType]
	lastEvaluatedKey: AWSJSON
	scannedCount: Int
}

type Mutation {
	CreateApiUser(tenant: String!, role: ApiUserRole!, description: String): ApiUser!
	CreateBitmapperFunction(
		tenant: String!,
		name: String!,
		code: String!,
		description: String!,
		argumentMessageType: String!,
		requirements: [String!]
	): BitmapperFunction!
	CreateCrossAccountApp(
		tenant: String!,
		name: String!,
		description: String,
		account: String!
	): ExternalApp!
	CreateEdge(
		tenant: String!, 
		source: String!, 
		target: String!, 
		kmsKey: String, 
		description: String
	): Edge!
	CreateExternalApp(
		tenant: String!,
		name: String!,
		description: String,
	): ExternalApp!
	CreateExternalNode(
		tenant: String!,
		app: String!,
		name: String!,
		receiveMessageType: String,
		sendMessageType: String
		description: String,
		config: AWSJSON,
	): ExternalNode!
	CreateKmsKey(tenant: String!, 	name: String!, description: String): KmsKey!
	CreateManagedApp(tenant: String!, name: String!, description: String): ManagedApp!
	CreateManagedNode(
		tenant: String!,
		app: String!,
		name: String!,
		managedNodeType: String!,
		description: String,
		config: AWSJSON,
		portMappings: [PortMappingInput!],
		hostMounts: [HostMountInput!]
	): ManagedNode!
	CreateManagedNodeType(
		tenant: String!, 
		name: String!,
		description: String,
		dockerConfig: DockerConfigInput!,
		configTemplate: AWSJSON,
		hostMountRequirements: [HostMountRequirementInput!],
		portMappingRequirements: [PortMappingRequirementInput!],
		volumes: [String!],
		sendMessageType: String,
		receiveMessageType: String,
		healthcheck: HealthcheckInput
	): ManagedNodeType!
	CreateMessageType(
		tenant: String!, 
		name: String!,
		auditor: String!,
		transformerTemplate: String!,
		bitmapperTemplate: String!,
		requirements: [String!]
	): MessageType!
	CreateNotification(old: AWSJSON, new: AWSJSON): Notification!
	@aws_iam
	CreateRouterNode(
		tenant: String!,
		name: String!,
		receiveMessageType: String!,
		inlineBitmapper: String,
		routeTable: AWSJSON!,
		managedBitmapper: String
		description: String,
		config: AWSJSON,
		requirements: [String!]
	): RouterNode!
	CreateTenant(name: String!, region: Region!, config: AWSJSON): Tenant!
	CreateTransformerFunction(
		tenant: String!,
		name: String!,
		code: String!,
		description: String!,
		argumentMessageType: String!,
		resultMessageType: String!,
		requirements: [String!]
	): TransformerFunction!
	CreateTransformerNode(
		tenant: String!,
		name: String!,
		receiveMessageType: String!,
		description: String,
		config: AWSJSON,
		sendMessageType: String,
		inlineTransformer: String,
		managedTransformer: String,
		sequentialProcessing: Boolean,
		requirements: [String!]
	): TransformerNode!
	CreateXTenantReceivingApp(
		tenant: String!, 
		name: String!, 
		sendingTenant: String!, 
		description: String
	): XTenantReceivingApp!
	CreateXTenantSendingApp(
		tenant: String!,
		name: String!,
		description: String,
		receivingTenant: String!,
		receivingApp: String!
	): XTenantSendingApp!
	CreateXTenantSendingNode(
		tenant: String!,
		app: String!,
		name: String!,
		receiveMessageType: String!,
		description: String,
		config: AWSJSON,
		sendMessageType: String,
		inlineTransformer: String,
		managedTransformer: String,
		sequentialProcessing: Boolean,
		requirements: [String!]
	): XTenantSendingNode!
}

interface Node {
	created: AtBy!
	description: String
	lastModified: AtBy!
	name: String!
	tenant: Tenant!
}

type NodeResult {
	items: [Node]
	lastEvaluatedKey: AWSJSON
	scannedCount: Int
}

union Notifiable = BitmapperFunction | CrossAccountApp | Edge |  ExternalApp | ExternalNode | KmsKey | ManagedApp | ManagedNode | ManagedNodeType | MessageType | RouterNode | Tenant | TransformerFunction | TransformerNode | XTenantReceivingApp | XTenantReceivingNode | XTenantSendingApp | XTenantSendingNode

type Notification {
	app: String,
	old: Notifiable,
	new: Notifiable
	tenant: String!,
}

enum PingStatus {
	ConnectionLost
	Inactive
	Online
}

type PortMapping {
	containerPort: Int!
	description: String!
	hostPort: Int!
}

input PortMappingInput {
	containerPort: Int!
	hostPort: Int!
}

type PortMappingRequirement {
	containerPort: Int!
	description: String!
}

input PortMappingRequirementInput {
	containerPort: Int!
	description: String!
}

type PresignedPost {
	expiration: AWSTimestamp!
	fields: AWSJSON!
	url: AWSURL!
}

type Query {
	GetApiUser(tenant: String!, username: String!): ApiUser
	GetApp(name: String!, tenant: String!): App
	GetEdge(source: String!, target: String!, tenant: String!): Edge
	GetFunction(name: String!, tenant: String): Function
	GetKmsKey(name: String!, tenant: String!): KmsKey
	GetLargeMessageStorage(tenant: String!, contentEncoding: ContentEncoding, count: Int): [LargeMessageStorage!]!
	GetManagedNodeType(name: String!, tenant: String): ManagedNodeType
	GetMessageType(name: String!, tenant: String): MessageType
	GetNode(name: String!, tenant: String!): Node
	GetTenant(tenant: String!): Tenant
	GetTenantUser(tenant: String!, email: AWSEmail!): TenantUser
	GetUser: LoginUser

	ListApiUsers(tenant: String!, limit: Int, startKey: AWSJSON): ApiUserResult
	ListApps(tenant: String!, limit: Int, nameContains: String, startKey: AWSJSON): AppResult
	ListFunctions(limit: Int, startKey: AWSJSON, tenant: String): FunctionResult
	ListKeys(tenant: String!, limit: Int, startKey: AWSJSON): KmsKeyResult
	ListNodes(tenant: String!, limit: Int, nameContains: String, startKey: AWSJSON): NodeResult
	ListManagedNodeTypes(limit: Int, startKey: String, tenant: String): ManagedNodeTypeResult
	ListMessageTypes(limit: Int, startKey: String, tenant: String): MessageTypeResult
	ListTenants(limit: Int, startKey: String): TenantResult
	ListTenantUsers(tenant: String!, limit: Int, startKey: AWSJSON): TenantUserResult
}

enum Region {
	af_south_1
	ap_east_1
	ap_northeast_1
	ap_northeast_2
	ap_northeast_3
	ap_south_1
	ap_southeast_1
	ap_southeast_2
	ca_central_1
	eu_central_1
	eu_north_1
	eu_south_1
	eu_west_1
	eu_west_2
	eu_west_3
	me_south_1
	sa_east_1
	us_east_1
	us_east_2
	us_west_1
	us_west_2
	us_gov_east_1
	us_gov_west_1
}

type RouterNode implements Node {
	config: AWSJSON
	created: AtBy!
	description: String
	inlineBitmapper: String
	lastModified: AtBy!
	managedBitmapper: BitmapperFunction
	name: String!
	receiveEdges: [Edge]
	receiveMessageType: MessageType
	requirements: [String!]
	routeTable: AWSJSON!
	sendEdges: [Edge]
	sendMessageType: MessageType
	tenant: Tenant!

	Delete(drainEdges: Boolean): Boolean!
	ListLogEvents(endDateTime: AWSDateTime, filterPattern: String, limit: Int, nextToken: String, startDateTime: AWSDateTime): LogEventResults!
	Update(config: AWSJSON, description: String, inlineBitmapper: String, managedBitmapper: String, requirements: [String!], routeTable: AWSJSON): RouterNode!
	Validate(message: String!, code: String, loggingLevel: LogLevel): ValidateResult!
}

type Subscription {
	onNotification(tenant: String!, app: String): Notification
	@aws_subscribe(mutations: ["createNotification"])
}

type Tenant {
	config: AWSJSON
	created: AtBy!
	description: String
	lastModified: AtBy!
	name: String!
	region: String!
	users: [TenantUser!]

	AddUser(email: String!, role: UserRole!): TenantUser!
	Delete: Boolean!
	Update(config: AWSJSON, description: String): Tenant!
}

type TenantResult {
	items: [Tenant]
	lastEvaluatedKey: AWSJSON
	scannedCount: Int
}

type TenantUser {
	activeDate: String
	created: AtBy!
	email: AWSEmail!
	firstName: String
	invitationDate: String
	invitationToken: String
	lastModified: AtBy!
	lastName: String
	role: UserRole!
	status: UserStatus!
	tenant: Tenant!

	Delete: Boolean!
	Update(role: UserRole, status: UserStatus): TenantUser!
}

type TenantUserResult {
	items: [TenantUser]
	lastEvaluatedKey: AWSJSON
	scannedCount: Int
}

type TransformerFunction implements Function @aws_cognito_user_pool {
	argumentMessageType: MessageType!
	code: String!
	created: AtBy!
	description: String!
	lastModified: AtBy!
	name: String!
	requirements: [String!]
	resultMessageType: MessageType!
	system: Boolean!
	tenant: Tenant

	Delete: Boolean!
	Update(code: String, description: String, requirements: [String!]): TransformerFunction!
	Validate(message: String!, code: String, loggingLevel: LogLevel): ValidateResult!
}

type TransformerNode implements Node {
	config: AWSJSON
	created: AtBy!
	description: String
	inlineTransformer: String
	lastModified: AtBy!
	managedTransformer: TransformerFunction
	name: String!
	receiveEdges: [Edge]
	receiveMessageType: MessageType
	requirements: [String!]
	sendEdges: [Edge]
	sendMessageType: MessageType
	sequentialProcessing: Boolean
	tenant: Tenant!

	Delete(drainEdges: Boolean): Boolean!
	ListLogEvents(endDateTime: AWSDateTime, filterPattern: String, limit: Int, nextToken: String, startDateTime: AWSDateTime): LogEventResults!
	Update(config: AWSJSON, description: String, inlineTransformer: String, inlineTransformer: String, requirements: [String!], sequentialProcessing: Boolean): TransformerNode!
	Validate(message: String!, code: String, loggingLevel: LogLevel): ValidateResult!
}

enum UserRole {
	admin
	owner
	read_only
	user
}

enum UserStatus {
	active
	inactive
	invited
	pending
}

type ValidateResult {
	result: String!
	stdout: String!
}

type XTenantReceivingApp implements App {
	created: AtBy!
	description: String
	lastModified: AtBy!
	name: String!
	nodes: [XTenantReceivingNode]
	sendingApp: String
	sendingTenant: String!
	tenant: Tenant!

	Delete(drainEdges: Boolean): Boolean!
	Update(description: String): XTenantReceivingApp!
}

type XTenantReceivingNode implements Node {
	app: XTenantReceivingApp!
	created: AtBy!
	description: String
	lastModified: AtBy!
	name: String!
	sendEdges: [Edge]
	sendMessageType: MessageType
	tenant: Tenant!

	Delete(drainEdges: Boolean): Boolean!
	Update(description: String): XTenantReceivingNode!
}

type XTenantSendingApp implements App {
	created: AtBy!
	description: String
	lastModified: AtBy!
	name: String!
	nodes: [XTenantSendingNode]
	receivingApp: String!
	receivingTenant: String!
	tenant: Tenant!
	
	Delete(drainEdges: Boolean): Boolean!
	Update(description: String): XTenantSendingApp!
}

type XTenantSendingNode implements Node {
	app: XTenantSendingApp!
	config: AWSJSON
	created: AtBy!
	description: String
	inlineTransformer: String
	lastModified: AtBy!
	managedTransformer: TransformerFunction
	name: String!
	receiveEdges: [Edge]
	receiveMessageType: MessageType
	requirements: [String!]
	sequentialProcessing: Boolean
	tenant: Tenant!

	Delete(drainEdges: Boolean): Boolean!
	ListLogEvents(endDateTime: AWSDateTime, filterPattern: String, limit: Int, nextToken: String, startDateTime: AWSDateTime): LogEventResults!
	Update(config: AWSJSON, description: String, inlineTransformer: String, inlineTransformer: String, requirements: [String!], sequentialProcessing: Boolean): XTenantSendingNode!
	Validate(message: String!, code: String, loggingLevel: LogLevel): ValidateResult!
}
